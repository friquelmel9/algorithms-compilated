\section{Problemas DP Knapsack}

El problema de Knapsack se tiene de dos formatos distintos:

\begin{itemize}
    
    \item \textbf{Knapsack 0/1}: Estos problemas tienen el requerimiento de que un item se puede tomar unicamente una vez. 
    Generalmente siguen el formato dp[i][w], donde representa el valor buscado tomando i cantidad de items, y con peso w
    
    \item \textbf{Unbonded Knapsack}: Estos problemas pueden repetir un item cuantas veces quieran. Generalmente son de la forma dp\_value[cant]

\end{itemize}

\subsection{Knapsack 0/1}

Implement a solution to the classic knapsack problem. You are given a knapsack that can hold up to a
certain weight (its capacity), and several items you may choose to put in the knapsack. Each item has
a weight and a value. Choose a subset of the items (which could be all of them, or none of them)
having the greatest value that fit into the knapsack (i.e. the sum of the weights of the items you
choose must be less than or equal to the knapsack capacity).

\subsubsection{Input}

The input consists of between 1 and 30 test cases. Each test case begins with an integer $1 \leq C \leq
2\,000$, giving the capacity of the knapsack, and an integer $1 \leq n \leq 2\,000$, giving the number of
objects. Then follow $n$ lines, each giving the value and weight of the $n$ objects. Both values and
weights are integers between 1 and $10\,000$.

\subsubsection{Output}

For each test case, output a line containing the number of items chosen, followed by a line
containing the indices of the chosen items (the first item has index 0, the second index 1, and so on).
The indices can be given in any order.

\subsubsection{Example 1: }

5 3 \\
1 5 \\
10 5 \\
100 5
6 4 \\
5 4 \\
4 3 \\
3 2 \\
2 1 

\subsubsection{Output Example 1: }

1 \\
2 \\
3 \\
1 2 3 

\begin{cppcode}
    
#include <bits/stdc++.h>

#define ll long long

struct Object{
    ll value;
    ll weight;
};

void knapstack(ll capacity, std::vector<Object>& objects, std::vector<std::vector<ll>>& dp){
        
    for(ll i=1; i<=objects.size(); i++){
        ll curr_value = objects[i-1].value;
        ll curr_weight = objects[i-1].weight;
        
        for(ll w=1; w<=capacity; w++){ 
            if(curr_weight > w){ dp[i][w] = dp[i-1][w]; }
            else{
                ll not_take_value = dp[i-1][w];
                ll take_value = curr_value + dp[i-1][w - curr_weight];
                dp[i][w] = std::max(not_take_value, take_value);
            }
        }
        
    }
        
    std::vector<ll> selected_objects;
    ll curr_weight = capacity;
    
    for(ll i = objects.size(); i > 0; i--){
        
        if(dp[i][curr_weight] != dp[i-1][curr_weight]){
            selected_objects.push_back(i-1);
            curr_weight -= objects[i-1].weight;
        }
    }
    
    // Output
    
    std::cout << selected_objects.size() << std::endl;
    for(ll i=0; i<selected_objects.size(); i++){
        std::string s = " ";
        if(i == selected_objects.size()-1){ s = ""; }
        std::cout << selected_objects[i] << s; 
    }
    std::cout << std::endl;
}

int main(){
    
    ll capacity, n_objects;
    while(std::cin >> capacity >> n_objects){
        std::vector<Object> objects(n_objects);
        for(ll i=0; i<n_objects; i++) { std::cin >> objects[i].value >> objects[i].weight; }
        
        std::vector<std::vector<ll>> dp(n_objects+1, std::vector<ll>(capacity+1, 0));
        knapstack(capacity,objects,dp);
    }
    
    return 0;
}
    
\end{cppcode}

\subsection{Vacaciones}

Taro's summer vacation starts tomorrow, and he has decided to make plans for it now.

The vacation consists of $N$ days. For each $i$ ($1 \le i \le N$), Taro will choose one of the following activities and do it on the $i$-th day:
\begin{itemize}
    \item \textbf{A}: Swim in the sea. Gain $a_i$ points of happiness.
    \item \textbf{B}: Catch bugs in the mountains. Gain $b_i$ points of happiness.
    \item \textbf{C}: Do homework at home. Gain $c_i$ points of happiness.
\end{itemize}

As Taro gets bored easily, he cannot do the same activities for two or more consecutive days.

Find the maximum possible total points of happiness that Taro gains.

\subsubsection{Constraints}

\begin{itemize}
    \item All values in input are integers.
    \item $1 \le N \le 10^5$
    \item $1 \le a_i, b_i, c_i \le 10^4$
\end{itemize}

\subsubsection{Input Example 1}

3 \\
10 40 70 \\
20 50 80 \\
30 60 90 

\subsubsection{Output Example 1}

210

\begin{cppcode}
    
#include <bits/stdc++.h>

#define optimize() std::ios_base::sync_with_stdio(false) ; std::cin.tie(NULL) ; std::cout.tie(NULL) ;

#define ll long long

#define A_INDEX 0
#define B_INDEX 1
#define C_INDEX 2

struct DayActivity{
    ll A;
    ll B;
    ll C;
};

ll tabulation(std::vector<DayActivity> &activities, std::vector<std::vector<ll>> &dp){
    
    dp[0][A_INDEX] = 0;
    dp[0][B_INDEX] = 0;
    dp[0][C_INDEX] = 0;
    
    for(ll i=1; i<=activities.size(); i++){
        
        dp[i][A_INDEX] = activities[i-1].A + std::max(dp[i-1][B_INDEX], dp[i-1][C_INDEX]);
        dp[i][B_INDEX] = activities[i-1].B + std::max(dp[i-1][A_INDEX], dp[i-1][C_INDEX]);
        dp[i][C_INDEX] = activities[i-1].C + std::max(dp[i-1][A_INDEX], dp[i-1][B_INDEX]);
        
    }
    
    return std::max({dp[activities.size()][A_INDEX],dp[activities.size()][B_INDEX],dp[activities.size()][C_INDEX]});
    
}

void testcase(){
    
    ll N_DAYS;
    std::cin >> N_DAYS;
    
    std::vector<DayActivity> activities(N_DAYS);
    for(ll i=0; i<N_DAYS; i++){std::cin >> activities[i].A >> activities[i].B >> activities[i].C; }
    
    std::vector<std::vector<ll>> dp(N_DAYS+1, std::vector<ll>(3,0));
    std::cout << tabulation(activities,dp) << std::endl;
    
}

int main(){
    optimize();
    testcase();
    return 0;
}
    
\end{cppcode}

\subsection{El oso negro}

Carlos, Nangel, Amanda, Bryan y Matías se fueron de campamento cerca de un lago. Felices y despreocupados, descuidaron todos los avisos que advertían sobre la repentina aparición de osos negros en el camping, y no guardaron sus alimentos en el almacén anti-osos (una caja de metal con candado) que se encuentra en cada puesto. Así, después de haber ido al lago cercano a pasear en kayak, al volver encontraron que todos los demás campistas estaban alborotados, produciendo mucho ruido, haciendo sonar las alarmas de los autos y gritando cosas como: "¡Fuera de aquí!", "¡Largo!", etc. Era un oso negro que, atraído por los víveres que los campistas siempre dejan fuera, se fue a ver qué conseguía.

Primero asustados, y luego maravillados, nuestros cinco campistas divisaron al oso. Era un oso adolescente, que no parecía particularmente agresivo. Amanda quiso acariciarlo, pero el resto del grupo la detuvo y, siguiendo las indicaciones que los guardaparques les habían provisto al llegar, se pusieron uno al lado del otro y abrieron los brazos para asustar al simpático individuo. El oso los miraba y no parecía particularmente asustado. En una actitud entre indiferente y curiosa, se quedó allí, observando a ver qué hacían sus víctimas, por supuesto, manteniendo su mirada en los víveres desprotegidos.

Los cinco campistas pronto comprendieron que deberían ceder ante las pretensiones del oso o, en caso contrario, serían ellos los que se convertirían en comida. Bryan sugirió que habría que darle como ofrenda algunos de los víveres y Matías asintió ante la condición de que se le ofreciera una dotación adecuadamente balanceada y equilibrada. Al fin y al cabo, no hay que hacerle daño a la pobre criatura. Todos los demás estaban de acuerdo.

Carlos, entonces, confeccionó una lista de alimentos disponibles, incluyendo, por cada uno, su valor calórico y un curioso "Índice de Sabrosidad para Osos" (o ISO), que, sospechosamente, encontró en algún blog de campistas en Internet. A Nangel le tocó la tarea de seleccionar los alimentos que entrarían a la ofrenda del oso que, a estas alturas, ya se había sentado en la mesa, mientras le preparaban la cena.

Por supuesto, Nangel escogerá una colección de alimentos que no sobrepase la recomendación de "ingesta de calorías diarias" recomendada para osos y que, a la vez, deje más contenta a la visita. Como se encuentra un poco asustado, se pregunta si puedes ayudarlo con la preparación del banquete.

\subsubsection*{Input}

La entrada consiste de los siguientes datos:

\begin{itemize}
    \item Primera línea: $1 \leq n \leq 1000$, $1 \leq C \leq 10000$, correspondientes al número de alimentos disponibles y al máximo valor de ingesta de calorías diarias recomendada para osos, respectivamente.
    \item Siguientes $n$ líneas: $\text{nombre}_i$, $0 \leq VC_i \leq 10000$, $0 \leq ISO_i \leq 10000$, correspondientes al nombre del alimento, su valor calórico y su índice de sabrosidad para osos.
\end{itemize}

\subsubsection*{Output}

Un número entero correspondiente a la sabrosidad total de la ofrenda preparada al oso.

\begin{cppcode}
    
#include <bits/stdc++.h>

#define optimize() std::ios_base::sync_with_stdio(false) ; std::cin.tie(NULL) ; std::cout.tie(NULL) ;

#define ll long long

struct Alimento{
    
    int valor_calorico;
    int indice_sabrosidad;
    
};

ll maximizeSabrosidad(std::vector<Alimento>&alimentos, int n_alimentos, int C_calorias){
    
    // El problema es un knaspack 0/1. 
    // Esta resolución lo hace mediante arreglo unidimensional, debido a las caracteristicas del problema
    // Basicamente, no requiere reconstrucción
    
    std::vector<ll> dp_knapsack(C_calorias+1,0); // Guarda el valor de sabrosidad
    
    // Caso base: La cantidad de sabrosidad sera 0 con 0 calorias.
    
    // Iteraciones
    
    for(int curr_al_idx = 0; curr_al_idx < n_alimentos; curr_al_idx++){
        
        int alimento_calorias = alimentos[curr_al_idx].valor_calorico;
        int alimento_sabrosidad = alimentos[curr_al_idx].indice_sabrosidad;
        
        for(int curr_calorias = C_calorias; curr_calorias >= 0; curr_calorias--){
            
            if(curr_calorias - alimento_calorias >= 0){
                
                dp_knapsack[curr_calorias] = std::max(
                    dp_knapsack[curr_calorias], 
                    dp_knapsack[curr_calorias-alimento_calorias] + alimento_sabrosidad
                );
                
            }
            
        }
        
    }
    
    return *std::max_element(dp_knapsack.begin(), dp_knapsack.end());
    
}

void solve(){
    
    int n_alimentos, C_calorias;
    // std::cin >> n_alimentos >> C_calorias; Se bugeaba con std::getline
    std::string line;
    std::getline(std::cin, line);
    std::stringstream ss_line(line);
    
    std::vector<std::string> input_vector;
    
    while(ss_line >> line){
            input_vector.push_back(line);
    }
    
    n_alimentos = std::stoi(input_vector[0]);
    C_calorias = std::stoi(input_vector[1]);
    
    std::vector<Alimento> alimentos(n_alimentos);
    
    for(int curr_idx = 0; curr_idx < n_alimentos; curr_idx++){
        
        std::getline(std::cin, line);
        std::stringstream ss_line(line);
        
        std::vector<std::string> input_vector;
        std::string input;
        
        while(ss_line >> input){
            input_vector.push_back(input);
        }
        
        // Los dos ultimos elemntos son los valores necesitados.
        alimentos[curr_idx].indice_sabrosidad = std::stoi(input_vector[input_vector.size()-1]);
        alimentos[curr_idx].valor_calorico = std::stoi(input_vector[input_vector.size()-2]);
        
    }
    
    std::cout << maximizeSabrosidad(alimentos,n_alimentos,C_calorias) << std::endl;
    
}

int main(){
    optimize();
    solve();
    return 0;
}
    
\end{cppcode}