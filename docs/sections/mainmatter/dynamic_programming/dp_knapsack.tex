\section{Problemas DP Knapsack}

El problema de Knapsack se tiene de dos formatos distintos:

\begin{itemize}
    
    \item \textbf{Knapsack 0/1}: Estos problemas tienen el requerimiento de que un item se puede tomar unicamente una vez. 
    Generalmente siguen el formato dp[i][w], donde representa el valor buscado tomando i cantidad de items, y con peso w
    
    \item \textbf{Unbonded Knapsack}: Estos problemas pueden repetir un item cuantas veces quieran. Generalmente son de la forma dp\_value[cant]

\end{itemize}

\subsection{Knapsack 0/1}

Implement a solution to the classic knapsack problem. You are given a knapsack that can hold up to a
certain weight (its capacity), and several items you may choose to put in the knapsack. Each item has
a weight and a value. Choose a subset of the items (which could be all of them, or none of them)
having the greatest value that fit into the knapsack (i.e. the sum of the weights of the items you
choose must be less than or equal to the knapsack capacity).

\subsubsection{Input}

The input consists of between 1 and 30 test cases. Each test case begins with an integer $1 \leq C \leq
2\,000$, giving the capacity of the knapsack, and an integer $1 \leq n \leq 2\,000$, giving the number of
objects. Then follow $n$ lines, each giving the value and weight of the $n$ objects. Both values and
weights are integers between 1 and $10\,000$.

\subsubsection{Output}

For each test case, output a line containing the number of items chosen, followed by a line
containing the indices of the chosen items (the first item has index 0, the second index 1, and so on).
The indices can be given in any order.

\subsubsection{Example 1: }

5 3 \\
1 5 \\
10 5 \\
100 5
6 4 \\
5 4 \\
4 3 \\
3 2 \\
2 1 

\subsubsection{Output Example 1: }

1 \\
2 \\
3 \\
1 2 3 

\begin{cppcode}
    
#include <bits/stdc++.h>

#define ll long long

struct Object{
    ll value;
    ll weight;
};

void knapstack(ll capacity, std::vector<Object>& objects, std::vector<std::vector<ll>>& dp){
        
    for(ll i=1; i<=objects.size(); i++){
        ll curr_value = objects[i-1].value;
        ll curr_weight = objects[i-1].weight;
        
        for(ll w=1; w<=capacity; w++){ 
            if(curr_weight > w){ dp[i][w] = dp[i-1][w]; }
            else{
                ll not_take_value = dp[i-1][w];
                ll take_value = curr_value + dp[i-1][w - curr_weight];
                dp[i][w] = std::max(not_take_value, take_value);
            }
        }
        
    }
        
    std::vector<ll> selected_objects;
    ll curr_weight = capacity;
    
    for(ll i = objects.size(); i > 0; i--){
        
        if(dp[i][curr_weight] != dp[i-1][curr_weight]){
            selected_objects.push_back(i-1);
            curr_weight -= objects[i-1].weight;
        }
    }
    
    // Output
    
    std::cout << selected_objects.size() << std::endl;
    for(ll i=0; i<selected_objects.size(); i++){
        std::string s = " ";
        if(i == selected_objects.size()-1){ s = ""; }
        std::cout << selected_objects[i] << s; 
    }
    std::cout << std::endl;
}

int main(){
    
    ll capacity, n_objects;
    while(std::cin >> capacity >> n_objects){
        std::vector<Object> objects(n_objects);
        for(ll i=0; i<n_objects; i++) { std::cin >> objects[i].value >> objects[i].weight; }
        
        std::vector<std::vector<ll>> dp(n_objects+1, std::vector<ll>(capacity+1, 0));
        knapstack(capacity,objects,dp);
    }
    
    return 0;
}
    
\end{cppcode}

\subsection{Vacaciones}

Taro's summer vacation starts tomorrow, and he has decided to make plans for it now.

The vacation consists of $N$ days. For each $i$ ($1 \le i \le N$), Taro will choose one of the following activities and do it on the $i$-th day:
\begin{itemize}
    \item \textbf{A}: Swim in the sea. Gain $a_i$ points of happiness.
    \item \textbf{B}: Catch bugs in the mountains. Gain $b_i$ points of happiness.
    \item \textbf{C}: Do homework at home. Gain $c_i$ points of happiness.
\end{itemize}

As Taro gets bored easily, he cannot do the same activities for two or more consecutive days.

Find the maximum possible total points of happiness that Taro gains.

\subsubsection{Constraints}

\begin{itemize}
    \item All values in input are integers.
    \item $1 \le N \le 10^5$
    \item $1 \le a_i, b_i, c_i \le 10^4$
\end{itemize}

\subsubsection{Input Example 1}

3 \\
10 40 70 \\
20 50 80 \\
30 60 90 

\subsubsection{Output Example 1}

210

\begin{cppcode}
    
#include <bits/stdc++.h>

#define optimize() std::ios_base::sync_with_stdio(false) ; std::cin.tie(NULL) ; std::cout.tie(NULL) ;

#define ll long long

#define A_INDEX 0
#define B_INDEX 1
#define C_INDEX 2

struct DayActivity{
    ll A;
    ll B;
    ll C;
};

ll tabulation(std::vector<DayActivity> &activities, std::vector<std::vector<ll>> &dp){
    
    dp[0][A_INDEX] = 0;
    dp[0][B_INDEX] = 0;
    dp[0][C_INDEX] = 0;
    
    for(ll i=1; i<=activities.size(); i++){
        
        dp[i][A_INDEX] = activities[i-1].A + std::max(dp[i-1][B_INDEX], dp[i-1][C_INDEX]);
        dp[i][B_INDEX] = activities[i-1].B + std::max(dp[i-1][A_INDEX], dp[i-1][C_INDEX]);
        dp[i][C_INDEX] = activities[i-1].C + std::max(dp[i-1][A_INDEX], dp[i-1][B_INDEX]);
        
    }
    
    return std::max({dp[activities.size()][A_INDEX],dp[activities.size()][B_INDEX],dp[activities.size()][C_INDEX]});
    
}

void testcase(){
    
    ll N_DAYS;
    std::cin >> N_DAYS;
    
    std::vector<DayActivity> activities(N_DAYS);
    for(ll i=0; i<N_DAYS; i++){std::cin >> activities[i].A >> activities[i].B >> activities[i].C; }
    
    std::vector<std::vector<ll>> dp(N_DAYS+1, std::vector<ll>(3,0));
    std::cout << tabulation(activities,dp) << std::endl;
    
}

int main(){
    optimize();
    testcase();
    return 0;
}
    
\end{cppcode}