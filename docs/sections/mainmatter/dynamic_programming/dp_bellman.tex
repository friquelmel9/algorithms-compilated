\section{Problemas DP Bellman}

El problema de encontrar caminos minimos con ciclos negativos es resuelto por Bellman. 

\subsection{Single source shortest path, negative weights (Bellmans)}

\subsubsection{Input}
The input consists of several test cases. Each test case starts with a line with four non-negative integers, $1 \le n \le 1000$, $0 \le m \le 5000$, $1 \le q \le 100$ and $0 \le s < n$, separated by single spaces, where $n$ is the number of nodes in the graph, $m$ the number of edges, $q$ the number of queries and $s$ the index of the starting node. Nodes are numbered from $0$ to $n - 1$. Then follow $m$ lines, each line consisting of three (space-separated) integers $u$, $v$ and $w$ indicating that there is an edge from $u$ to $v$ in the graph with weight $-2000 \le w \le 2000$. Then follow $q$ lines of queries, each consisting of a single non-negative integer, asking for the minimum distance from node $s$ to the node number given on the query line.

Input will be terminated by a line containing four zeros, this line should \textbf{not} be processed.

\subsubsection{Output}
For each query, output a single line containing the minimum distance from node $s$ to the node specified in the query, the word \texttt{"Impossible"} if there is no path from $s$ to that node, or \texttt{"-Infinity"} if there are arbitrarily short paths from $s$ to that node. For clarity, the sample output has a blank line between the output for different cases.

\begin{cppcode}
/**
    * Realiza el algoritmo de Bellman para encontrar distancias con aristas de peso negativo
    * Esta implementación considera el Grafo enlazado en partes previas del documento. Utilizar aquel.
    * 
    * @param s_node Nodo incial donde realizar el Bellman
    * @param ref_node Nodo que se quiere saber su valor de distancia desde s_node
    * 
    * @return Valor
    * 
    * @timecomplexity: O(V * E)
    * @spacecomplexity: O(2V) = O(V)
    */
int bellman(int s_node, int ref_node){
    
    std::vector<long long> dp_distances(n_nodes, INF); // Utiliza long long por si hay overflow
    std::vector<bool> dp_negative_cycle(n_nodes, false);
    
    // Caso base: dp[s_node]
    
    dp_distances[s_node] = 0;
    
    // Relajacion: n-1 iteraciones
    
    for(int curr_itr = 0; curr_itr < n_nodes - 1; curr_itr++){
        for(int curr_node = 0; curr_node < n_nodes; curr_node++){
            
            if(dp_distances[curr_node] == INF){continue;}
            
            std::vector<Edge>& adj = nodes[curr_node].adj;
            
            for(Edge edge : adj){
                
                int node_v = edge.node_v;
                
                long long new_dist = dp_distances[curr_node] + edge.weight; 
                
                if (new_dist < dp_distances[node_v]){
                    dp_distances[node_v] = new_dist;
                }
            }
        }
    }
    
    // Detección y Propagación de Ciclos Negativos
    
    // Primero, detectar qué nodos pueden ser relajados en la n-ésima iteración
    for(int curr_node = 0; curr_node < n_nodes; curr_node++){
        
        if(dp_distances[curr_node] == INF){ continue; }
        
        std::vector<Edge>& adj = nodes[curr_node].adj;
        
        for(Edge edge : adj){
            
            int node_v = edge.node_v;
            long long new_dist = dp_distances[curr_node] + edge.weight;
            
            // Si se puede relajar en la n-ésima iteración, está en un ciclo negativo o es alcanzable desde uno.
            if(new_dist < dp_distances[node_v]){
                dp_negative_cycle[node_v] = true;
            }
        }
    }
    
    // Segundo, propagar el estado de ciclo negativo a todos los nodos alcanzables.
    // Esto requiere n-1 iteraciones adicionales (similar a un BFS/DFS implícito)
    for(int curr_itr = 0; curr_itr < n_nodes - 1; curr_itr++){
        for(int curr_node = 0; curr_node < n_nodes; curr_node++){
            
            if(dp_negative_cycle[curr_node]){
                
                std::vector<Edge>& adj = nodes[curr_node].adj;
                
                for(Edge edge : adj){
                    int node_v = edge.node_v;
                    dp_negative_cycle[node_v] = true;
                }
            }
        }
    }
    
    // Retorno
    
    if(dp_distances[ref_node] == INF){return INF;} // No alcanzable
    else if(dp_negative_cycle[ref_node] == true){return -1; } // Negative cycle
    else{return dp_distances[ref_node]; } // Resolución
}
\end{cppcode}